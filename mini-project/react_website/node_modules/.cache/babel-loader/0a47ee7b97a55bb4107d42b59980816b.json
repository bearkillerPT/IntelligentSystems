{"ast":null,"code":"import fuzzy from './_fuzzy.js';\nimport methods from '../../termMethods.js'; //this should load off of 'methods.one.termMethods'\n//declare it up here\n\nvar wrapMatch = function wrapMatch() {};\n/** ignore optional/greedy logic, straight-up term match*/\n\n\nvar doesMatch = function doesMatch(term, reg, index, length) {\n  // support '.'\n  if (reg.anything === true) {\n    return true;\n  } // support '^' (in parentheses)\n\n\n  if (reg.start === true && index !== 0) {\n    return false;\n  } // support '$' (in parentheses)\n\n\n  if (reg.end === true && index !== length - 1) {\n    return false;\n  } //support a text match\n\n\n  if (reg.word !== undefined) {\n    // check case-sensitivity, etc\n    if (reg.use) {\n      return reg.word === term[reg.use];\n    } //match contractions, machine-form\n\n\n    if (term.machine !== null && term.machine === reg.word) {\n      return true;\n    } // term aliases for slashes and things\n\n\n    if (term.alias !== undefined && term.alias.hasOwnProperty(reg.word)) {\n      return true;\n    } // support ~ fuzzy match\n\n\n    if (reg.fuzzy === true) {\n      if (reg.word === term.root) {\n        return true;\n      }\n\n      var score = fuzzy(reg.word, term.normal);\n\n      if (score >= reg.min) {\n        return true;\n      }\n    } // match slashes and things\n\n\n    if (term.alias && term.alias.some(function (str) {\n      return str === reg.word;\n    })) {\n      return true;\n    } //match either .normal or .text\n\n\n    return reg.word === term.text || reg.word === term.normal;\n  } //support #Tag\n\n\n  if (reg.tag !== undefined) {\n    return term.tags.has(reg.tag) === true;\n  } //support @method\n\n\n  if (reg.method !== undefined) {\n    if (typeof methods[reg.method] === 'function' && methods[reg.method](term) === true) {\n      return true;\n    }\n\n    return false;\n  } //support whitespace/punctuation\n\n\n  if (reg.pre !== undefined) {\n    return term.pre && term.pre.includes(reg.pre);\n  }\n\n  if (reg.post !== undefined) {\n    return term.post && term.post.includes(reg.post);\n  } //support /reg/\n\n\n  if (reg.regex !== undefined) {\n    var str = term.normal;\n\n    if (reg.use) {\n      str = term[reg.use];\n    }\n\n    return reg.regex.test(str);\n  } //support <chunk>\n\n\n  if (reg.chunk !== undefined) {\n    return term.chunk === reg.chunk;\n  } //support %Noun|Verb%\n\n\n  if (reg.switch !== undefined) {\n    return term.switch === reg.switch;\n  } //support {machine}\n\n\n  if (reg.machine !== undefined) {\n    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;\n  } //support {word/sense}\n\n\n  if (reg.sense !== undefined) {\n    return term.sense === reg.sense;\n  } // support optimized (one|two)\n\n\n  if (reg.fastOr !== undefined) {\n    return reg.fastOr.has(term.implicit) || reg.fastOr.has(term.normal) || reg.fastOr.has(term.text) || reg.fastOr.has(term.machine);\n  } //support slower (one|two)\n\n\n  if (reg.choices !== undefined) {\n    // try to support && operator\n    if (reg.operator === 'and') {\n      // must match them all\n      return reg.choices.every(function (r) {\n        return wrapMatch(term, r, index, length);\n      });\n    } // or must match one\n\n\n    return reg.choices.some(function (r) {\n      return wrapMatch(term, r, index, length);\n    });\n  }\n\n  return false;\n}; // wrap result for !negative match logic\n\n\nwrapMatch = function wrapMatch(t, reg, index, length) {\n  var result = doesMatch(t, reg, index, length);\n\n  if (reg.negative === true) {\n    return !result;\n  }\n\n  return result;\n};\n\nexport default wrapMatch;","map":null,"metadata":{},"sourceType":"module"}