{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport world from './world.js';\nimport api from './methods/index.js';\n\nvar View = /*#__PURE__*/function () {\n  function View(document, pointer) {\n    var _this = this;\n\n    var groups = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, View);\n\n    // invisible props\n    [['document', document], ['world', world], ['_groups', groups], ['_cache', null], ['viewType', 'View']].forEach(function (a) {\n      Object.defineProperty(_this, a[0], {\n        value: a[1],\n        writable: true\n      });\n    });\n    this.ptrs = pointer;\n  }\n  /* getters:  */\n\n\n  _createClass(View, [{\n    key: \"update\",\n    // create a new View, from this one\n    value: function update(pointer) {\n      var m = new View(this.document, pointer); // send the cache down, too?\n\n      if (m._cache && pointer && pointer.length > 1) {\n        // only if it's full\n        var cache = [];\n        pointer.forEach(function (ptr) {\n          if (ptr.length === 1) {\n            cache.push(m._cache[ptr[0]]);\n          } // let [n, start, end] = ptr\n          // if (start === 0 && this.document[n][end - 1] && !this.document[n][end]) {\n          //   console.log('=-=-=-= here -=-=-=-')\n          // }\n\n        });\n        m._cache = cache;\n      }\n\n      m.world = this.world;\n      return m;\n    } // create a new View, from this one\n\n  }, {\n    key: \"toView\",\n    value: function toView(pointer) {\n      if (pointer === undefined) {\n        pointer = this.pointer;\n      }\n\n      var m = new View(this.document, pointer); // m._cache = this._cache // share this full thing\n\n      return m;\n    }\n  }, {\n    key: \"fromText\",\n    value: function fromText(input) {\n      var methods = this.methods; //assume ./01-tokenize is installed\n\n      var document = methods.one.tokenize.fromString(input, this.world);\n      var doc = new View(document);\n      doc.world = this.world;\n      doc.compute(['normal', 'lexicon']);\n\n      if (this.world.compute.preTagger) {\n        doc.compute('preTagger');\n      }\n\n      return doc;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      // clone the whole document\n      var document = this.document.slice(0);\n      document = document.map(function (terms) {\n        return terms.map(function (term) {\n          term = Object.assign({}, term);\n          term.tags = new Set(term.tags);\n          return term;\n        });\n      }); // clone only sub-document ?\n\n      var m = this.update(this.pointer);\n      m.document = document;\n      m._cache = this._cache; //clone this too?\n\n      return m;\n    }\n  }, {\n    key: \"docs\",\n    get: function get() {\n      var docs = this.document;\n\n      if (this.ptrs) {\n        docs = world.methods.one.getDoc(this.ptrs, this.document);\n      }\n\n      return docs;\n    }\n  }, {\n    key: \"pointer\",\n    get: function get() {\n      return this.ptrs;\n    }\n  }, {\n    key: \"methods\",\n    get: function get() {\n      return this.world.methods;\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this.world.model;\n    }\n  }, {\n    key: \"hooks\",\n    get: function get() {\n      return this.world.hooks;\n    }\n  }, {\n    key: \"isView\",\n    get: function get() {\n      return true; //this comes in handy sometimes\n    } // is the view not-empty?\n\n  }, {\n    key: \"found\",\n    get: function get() {\n      return this.docs.length > 0;\n    } // how many matches we have\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.docs.length;\n    } // return a more-hackable pointer\n\n  }, {\n    key: \"fullPointer\",\n    get: function get() {\n      var docs = this.docs,\n          ptrs = this.ptrs,\n          document = this.document; // compute a proper pointer, from docs\n\n      var pointers = ptrs || docs.map(function (_d, n) {\n        return [n];\n      }); // do we need to repair it, first?\n\n      return pointers.map(function (a) {\n        var _a = _slicedToArray(a, 5),\n            n = _a[0],\n            start = _a[1],\n            end = _a[2],\n            id = _a[3],\n            endId = _a[4];\n\n        start = start || 0;\n        end = end || (document[n] || []).length; //add frozen id, for good-measure\n\n        if (document[n] && document[n][start]) {\n          id = id || document[n][start].id;\n\n          if (document[n][end - 1]) {\n            endId = endId || document[n][end - 1].id;\n          }\n        }\n\n        return [n, start, end, id, endId];\n      });\n    }\n  }]);\n\n  return View;\n}();\n\nObject.assign(View.prototype, api);\nexport default View;","map":null,"metadata":{},"sourceType":"module"}