{"ast":null,"code":"import doesMatch from '../../term/doesMatch.js';\n\nvar isArray = function isArray(arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\n\nexport var doOrBlock = function doOrBlock(state) {\n  var skipN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var block = state.regs[state.r];\n  var wasFound = false; // do each multiword sequence\n\n  for (var c = 0; c < block.choices.length; c += 1) {\n    // try to match this list of tokens\n    var regs = block.choices[c];\n\n    if (!isArray(regs)) {\n      return false;\n    }\n\n    wasFound = regs.every(function (cr, w_index) {\n      var extra = 0;\n      var t = state.t + w_index + skipN + extra;\n\n      if (state.terms[t] === undefined) {\n        return false;\n      }\n\n      var foundBlock = doesMatch(state.terms[t], cr, t + state.start_i, state.phrase_length); // this can be greedy - '(foo+ bar)'\n\n      if (foundBlock === true && cr.greedy === true) {\n        for (var i = 1; i < state.terms.length; i += 1) {\n          var term = state.terms[t + i];\n\n          if (term) {\n            var keepGoing = doesMatch(term, cr, state.start_i + i, state.phrase_length);\n\n            if (keepGoing === true) {\n              extra += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n      skipN += extra;\n      return foundBlock;\n    });\n\n    if (wasFound) {\n      skipN += regs.length;\n      break;\n    }\n  } // we found a match -  is it greedy though?\n\n\n  if (wasFound && block.greedy === true) {\n    return doOrBlock(state, skipN); // try it again!\n  }\n\n  return skipN;\n};\n\nvar doAndBlock = function doAndBlock(state) {\n  var longest = 0; // all blocks must match, and we return the greediest match\n\n  var reg = state.regs[state.r];\n  var allDidMatch = reg.choices.every(function (block) {\n    //  for multi-word blocks, all must match\n    var allWords = block.every(function (cr, w_index) {\n      var tryTerm = state.t + w_index;\n\n      if (state.terms[tryTerm] === undefined) {\n        return false;\n      }\n\n      return doesMatch(state.terms[tryTerm], cr, tryTerm, state.phrase_length);\n    });\n\n    if (allWords === true && block.length > longest) {\n      longest = block.length;\n    }\n\n    return allWords;\n  });\n\n  if (allDidMatch === true) {\n    // console.log(`doAndBlock ${state.terms[state.t].normal}`)\n    return longest;\n  }\n\n  return false;\n};\n\nexport { doAndBlock };","map":null,"metadata":{},"sourceType":"module"}