{"ast":null,"code":"import { getGroup } from '../_lib.js';\nimport foundOptional from './optional-match.js';\nimport greedyMatch from './greedy-match.js';\nimport contractionSkip from './contraction-skip.js'; // '[foo]' should also be logged as a group\n\nvar setGroup = function setGroup(state, startAt) {\n  var reg = state.regs[state.r]; // Get or create capture group\n\n  var g = getGroup(state, startAt); // Update group - add greedy or increment length\n\n  if (state.t > 1 && reg.greedy) {\n    g.length += state.t - startAt;\n  } else {\n    g.length++;\n  }\n}; // when a reg matches a term\n\n\nvar simpleMatch = function simpleMatch(state) {\n  var regs = state.regs;\n  var reg = regs[state.r];\n  var term = state.terms[state.t];\n  var startAt = state.t; // if it's a negative optional match... :0\n\n  if (reg.optional && regs[state.r + 1] && reg.negative) {\n    return true;\n  } // okay, it was a match, but if it's optional too,\n  // we should check the next reg too, to skip it?\n\n\n  if (reg.optional && regs[state.r + 1]) {\n    foundOptional(state);\n  } // Contraction skip:\n  // did we match the first part of a contraction?\n\n\n  if (term.implicit && state.terms[state.t + 1]) {\n    contractionSkip(state);\n  } //advance to the next term!\n\n\n  state.t += 1; //check any ending '$' flags\n  //if this isn't the last term, refuse the match\n\n  if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) {\n    return null; //die\n  } // keep 'foo+' going...\n\n\n  if (reg.greedy === true) {\n    var alive = greedyMatch(state);\n\n    if (!alive) {\n      return null;\n    }\n  } // log '[foo]' as a group\n\n\n  if (state.hasGroup === true) {\n    setGroup(state, startAt);\n  }\n\n  return true;\n};\n\nexport default simpleMatch;","map":null,"metadata":{},"sourceType":"module"}