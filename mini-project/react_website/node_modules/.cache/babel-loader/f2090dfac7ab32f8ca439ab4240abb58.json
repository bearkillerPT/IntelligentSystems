{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport splice from './_splice.js';\nimport apostropheD from './apostrophe-d.js';\nimport apostropheT from './apostrophe-t.js';\nimport french from './french.js';\nimport numberRange from './number-range.js';\nvar byApostrophe = /'/;\nvar numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/; // run tagger on our new implicit terms\n\nvar reTag = function reTag(terms, view, start, len) {\n  var tmp = view.update();\n  tmp.document = [terms]; // offer to re-tag neighbours, too\n\n  var end = start + len;\n\n  if (start > 0) {\n    start -= 1;\n  }\n\n  if (terms[end]) {\n    end += 1;\n  }\n\n  tmp.ptrs = [[0, start, end]];\n  tmp.compute('lexicon');\n\n  if (tmp.world.compute.preTagger) {\n    tmp.compute('preTagger');\n  }\n};\n\nvar byEnd = {\n  // ain't\n  t: function t(terms, i) {\n    return apostropheT(terms, i);\n  },\n  // how'd\n  d: function d(terms, i) {\n    return apostropheD(terms, i);\n  }\n};\nvar byStart = {\n  // j'aime\n  j: function j(terms, i) {\n    return french.preJ(terms, i);\n  },\n  // l'amour\n  l: function l(terms, i) {\n    return french.preL(terms, i);\n  },\n  // d'amerique\n  d: function d(terms, i) {\n    return french.preD(terms, i);\n  }\n}; // pull-apart known contractions from model\n\nvar knownOnes = function knownOnes(list, term, before, after) {\n  for (var i = 0; i < list.length; i += 1) {\n    var o = list[i]; // look for word-word match (cannot-> [can, not])\n\n    if (o.word === term.normal) {\n      return o.out;\n    } // look for after-match ('re -> [_, are])\n    else if (after !== null && after === o.after) {\n      return [before].concat(o.out);\n    } // look for before-match (l' -> [le, _])\n    else if (before !== null && before === o.before) {\n      return o.out.concat(after); // return [o.out, after] //typeof o.out === 'string' ? [o.out, after] : o.out(terms, i)\n    }\n  }\n\n  return null;\n};\n\nvar toDocs = function toDocs(words, view) {\n  var doc = view.fromText(words.join(' '));\n  doc.compute('id');\n  return doc.docs[0];\n}; //really easy ones\n\n\nvar contractions = function contractions(view) {\n  var world = view.world,\n      document = view.document;\n  var model = world.model,\n      methods = world.methods;\n  var list = model.one.contractions || []; // each sentence\n\n  document.forEach(function (terms, n) {\n    // loop through terms backwards\n    for (var i = terms.length - 1; i >= 0; i -= 1) {\n      var before = null;\n      var after = null;\n\n      if (byApostrophe.test(terms[i].normal) === true) {\n        var _terms$i$normal$split = terms[i].normal.split(byApostrophe);\n\n        var _terms$i$normal$split2 = _slicedToArray(_terms$i$normal$split, 2);\n\n        before = _terms$i$normal$split2[0];\n        after = _terms$i$normal$split2[1];\n      } // any known-ones, like 'dunno'?\n\n\n      var words = knownOnes(list, terms[i], before, after); // ['foo', 's']\n\n      if (!words && byEnd.hasOwnProperty(after)) {\n        words = byEnd[after](terms, i, world);\n      } // ['j', 'aime']\n\n\n      if (!words && byStart.hasOwnProperty(before)) {\n        words = byStart[before](terms, i);\n      } // actually insert the new terms\n\n\n      if (words) {\n        words = toDocs(words, view);\n        splice(document, [n, i], words);\n        reTag(document[n], view, i, words.length);\n        continue;\n      } // '44-2' has special care\n\n\n      if (numDash.test(terms[i].normal)) {\n        words = numberRange(terms, i);\n\n        if (words) {\n          words = toDocs(words, view);\n          splice(document, [n, i], words);\n          methods.one.setTag(words, 'NumberRange', world); //add custom tag\n          // is it a time-range, like '5-9pm'\n\n          if (words[2] && words[2].tags.has('Time')) {\n            methods.one.setTag([words[0]], 'Time', world);\n          }\n\n          reTag(document[n], view, i, words.length);\n        }\n      }\n    }\n  });\n};\n\nexport default contractions;","map":null,"metadata":{},"sourceType":"module"}