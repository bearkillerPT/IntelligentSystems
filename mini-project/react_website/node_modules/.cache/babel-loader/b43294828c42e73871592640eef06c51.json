{"ast":null,"code":"// fuzzy-match (damerau-levenshtein)\n// Based on  tad-lispy /node-damerau-levenshtein\n// https://github.com/tad-lispy/node-damerau-levenshtein/blob/master/index.js\n// count steps (insertions, deletions, substitutions, or transpositions)\nvar editDistance = function editDistance(strA, strB) {\n  var aLength = strA.length,\n      bLength = strB.length; // fail-fast\n\n  if (aLength === 0) {\n    return bLength;\n  }\n\n  if (bLength === 0) {\n    return aLength;\n  } // If the limit is not defined it will be calculate from this and that args.\n\n\n  var limit = (bLength > aLength ? bLength : aLength) + 1;\n\n  if (Math.abs(aLength - bLength) > (limit || 100)) {\n    return limit || 100;\n  } // init the array\n\n\n  var matrix = [];\n\n  for (var i = 0; i < limit; i++) {\n    matrix[i] = [i];\n    matrix[i].length = limit;\n  }\n\n  for (var _i = 0; _i < limit; _i++) {\n    matrix[0][_i] = _i;\n  } // Calculate matrix.\n\n\n  var j, a_index, b_index, cost, min, t;\n\n  for (var _i2 = 1; _i2 <= aLength; ++_i2) {\n    a_index = strA[_i2 - 1];\n\n    for (j = 1; j <= bLength; ++j) {\n      // Check the jagged distance total so far\n      if (_i2 === j && matrix[_i2][j] > 4) {\n        return aLength;\n      }\n\n      b_index = strB[j - 1];\n      cost = a_index === b_index ? 0 : 1; // Step 5\n      // Calculate the minimum (much faster than Math.min(...)).\n\n      min = matrix[_i2 - 1][j] + 1; // Deletion.\n\n      if ((t = matrix[_i2][j - 1] + 1) < min) min = t; // Insertion.\n\n      if ((t = matrix[_i2 - 1][j - 1] + cost) < min) min = t; // Substitution.\n      // Update matrix.\n\n      var shouldUpdate = _i2 > 1 && j > 1 && a_index === strB[j - 2] && strA[_i2 - 2] === b_index && (t = matrix[_i2 - 2][j - 2] + cost) < min;\n\n      if (shouldUpdate) {\n        matrix[_i2][j] = t;\n      } else {\n        matrix[_i2][j] = min;\n      }\n    }\n  } // return number of steps\n\n\n  return matrix[aLength][bLength];\n}; // score similarity by from 0-1 (steps/length)\n\n\nvar fuzzyMatch = function fuzzyMatch(strA, strB) {\n  var minLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n\n  if (strA === strB) {\n    return 1;\n  } //don't even bother on tiny strings\n\n\n  if (strA.length < minLength || strB.length < minLength) {\n    return 0;\n  }\n\n  var steps = editDistance(strA, strB);\n  var length = Math.max(strA.length, strB.length);\n  var relative = length === 0 ? 0 : steps / length;\n  var similarity = 1 - relative;\n  return similarity;\n};\n\nexport default fuzzyMatch;","map":null,"metadata":{},"sourceType":"module"}