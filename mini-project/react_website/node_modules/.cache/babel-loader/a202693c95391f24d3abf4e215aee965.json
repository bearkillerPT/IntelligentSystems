{"ast":null,"code":"import doAstrix from './steps/astrix.js';\nimport doOrBlock from './steps/or-block.js';\nimport doAndBlock from './steps/and-block.js';\nimport doNegative from './steps/negative.js';\nimport simpleMatch from './steps/simple-match.js';\nimport { isEndGreedy } from './steps/logic/greedy.js';\nimport matchTerm from './term/doesMatch.js'; // i formally apologize for how complicated this is.\n\n/** \n * try a sequence of match tokens ('regs') \n * on a sequence of terms, \n * starting at this certain term.\n */\n\nvar tryHere = function tryHere(terms, regs, start_i, phrase_length) {\n  if (terms.length === 0 || regs.length === 0) {\n    return null;\n  } // all the variables that matter\n\n\n  var state = {\n    t: 0,\n    terms: terms,\n    r: 0,\n    regs: regs,\n    groups: {},\n    start_i: start_i,\n    phrase_length: phrase_length,\n    inGroup: null\n  }; // we must satisfy every token in 'regs'\n  // if we get to the end, we have a match.\n\n  for (; state.r < regs.length; state.r += 1) {\n    var reg = regs[state.r]; // Check if this reg has a named capture group\n\n    state.hasGroup = Boolean(reg.group); // Reuse previous capture group if same\n\n    if (state.hasGroup === true) {\n      state.inGroup = reg.group;\n    } else {\n      state.inGroup = null;\n    } //have we run-out of terms?\n\n\n    if (!state.terms[state.t]) {\n      //are all remaining regs optional or negative?\n      var alive = regs.slice(state.r).some(function (remain) {\n        return !remain.optional;\n      });\n\n      if (alive === false) {\n        break; //done!\n      }\n\n      return null; // die\n    } // support 'unspecific greedy' .* properly\n\n\n    if (reg.anything === true && reg.greedy === true) {\n      var _alive = doAstrix(state);\n\n      if (!_alive) {\n        return null;\n      }\n\n      continue;\n    } // slow-OR - multi-word OR (a|b|foo bar)\n\n\n    if (reg.choices !== undefined && reg.operator === 'or') {\n      var _alive2 = doOrBlock(state);\n\n      if (!_alive2) {\n        return null;\n      }\n\n      continue;\n    } // slow-AND - multi-word AND (#Noun && foo) blocks\n\n\n    if (reg.choices !== undefined && reg.operator === 'and') {\n      var _alive3 = doAndBlock(state);\n\n      if (!_alive3) {\n        return null;\n      }\n\n      continue;\n    } // support '.' as any-single\n\n\n    if (reg.anything === true) {\n      var _alive4 = simpleMatch(state);\n\n      if (!_alive4) {\n        return null;\n      }\n\n      continue;\n    } // support 'foo*$' until the end\n\n\n    if (isEndGreedy(reg, state) === true) {\n      var _alive5 = simpleMatch(state);\n\n      if (!_alive5) {\n        return null;\n      }\n\n      continue;\n    } // ok, finally test the term-reg\n\n\n    var hasMatch = matchTerm(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length);\n\n    if (hasMatch === true) {\n      var _alive6 = simpleMatch(state);\n\n      if (!_alive6) {\n        return null;\n      }\n\n      continue;\n    } // ok, it doesn't match - but maybe it wasn't *supposed* to?\n\n\n    if (reg.negative) {\n      var _alive7 = doNegative(state);\n\n      if (!_alive7) {\n        return null;\n      }\n    } //ok who cares, keep going\n\n\n    if (reg.optional === true) {\n      continue;\n    } // finally, we die\n\n\n    return null;\n  } //return our results, as pointers\n\n\n  var pntr = [null, start_i, state.t + start_i];\n\n  if (pntr[1] === pntr[2]) {\n    return null; //found 0 terms\n  }\n\n  var groups = {};\n  Object.keys(state.groups).forEach(function (k) {\n    var o = state.groups[k];\n    var start = start_i + o.start;\n    groups[k] = [null, start, start + o.length];\n  });\n  return {\n    pointer: pntr,\n    groups: groups\n  };\n};\n\nexport default tryHere;","map":null,"metadata":{},"sourceType":"module"}