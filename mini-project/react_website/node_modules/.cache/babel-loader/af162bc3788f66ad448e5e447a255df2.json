{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport fns from './fns.js';\nimport _pack from './pack.js';\nvar NOT_ALLOWED = new RegExp('[0-9A-Z,;!:|Â¦]'); //characters banned from entering the trie\n\nvar methods = {\n  // Insert words from one big string, or from an array.\n  insertWords: function insertWords(words) {\n    if (words === undefined) {\n      return;\n    }\n\n    if (typeof words === 'string') {\n      words = words.split(/[^a-zA-Z]+/);\n    }\n\n    for (var i = 0; i < words.length; i++) {\n      words[i] = words[i].toLowerCase();\n    }\n\n    fns.unique(words);\n\n    for (var _i = 0; _i < words.length; _i++) {\n      if (words[_i].match(NOT_ALLOWED) === null) {\n        this.insert(words[_i]);\n      }\n    }\n  },\n  insert: function insert(word) {\n    this._insert(word, this.root);\n\n    var lastWord = this.lastWord;\n    this.lastWord = word;\n    var prefix = fns.commonPrefix(word, lastWord);\n\n    if (prefix === lastWord) {\n      return;\n    }\n\n    var freeze = this.uniqueNode(lastWord, word, this.root);\n\n    if (freeze) {\n      this.combineSuffixNode(freeze);\n    }\n  },\n  _insert: function _insert(word, node) {\n    var prefix, next; // Duplicate word entry - ignore\n\n    if (word.length === 0) {\n      return;\n    } // Do any existing props share a common prefix?\n\n\n    var keys = Object.keys(node);\n\n    for (var i = 0; i < keys.length; i++) {\n      var prop = keys[i];\n      prefix = fns.commonPrefix(word, prop);\n\n      if (prefix.length === 0) {\n        continue;\n      } // Prop is a proper prefix - recurse to child node\n\n\n      if (prop === prefix && _typeof(node[prop]) === 'object') {\n        this._insert(word.slice(prefix.length), node[prop]);\n\n        return;\n      } // Duplicate terminal string - ignore\n\n\n      if (prop === word && typeof node[prop] === 'number') {\n        return;\n      }\n\n      next = {};\n      next[prop.slice(prefix.length)] = node[prop];\n      this.addTerminal(next, word = word.slice(prefix.length));\n      delete node[prop];\n      node[prefix] = next;\n      this.wordCount++;\n      return;\n    } // No shared prefix.  Enter the word here as a terminal string.\n\n\n    this.addTerminal(node, word);\n    this.wordCount++;\n  },\n  // Add a terminal string to node.\n  // If 2 characters or less, just add with value == 1.\n  // If more than 2 characters, point to shared node\n  // Note - don't prematurely share suffixes - these\n  // terminals may become split and joined with other\n  // nodes in this part of the tree.\n  addTerminal: function addTerminal(node, prop) {\n    if (prop.length <= 1) {\n      node[prop] = 1;\n      return;\n    }\n\n    var next = {};\n    node[prop[0]] = next;\n    this.addTerminal(next, prop.slice(1));\n  },\n  // Well ordered list of properties in a node (string or object properties)\n  // Use nodesOnly==true to return only properties of child nodes (not\n  // terminal strings.\n  nodeProps: function nodeProps(node, nodesOnly) {\n    var props = [];\n\n    for (var prop in node) {\n      if (prop !== '' && prop[0] !== '_') {\n        if (!nodesOnly || _typeof(node[prop]) === 'object') {\n          props.push(prop);\n        }\n      }\n    }\n\n    props.sort();\n    return props;\n  },\n  optimize: function optimize() {\n    this.combineSuffixNode(this.root);\n    this.prepDFS();\n    this.countDegree(this.root);\n    this.prepDFS();\n    this.collapseChains(this.root);\n  },\n  // Convert Trie to a DAWG by sharing identical nodes\n  combineSuffixNode: function combineSuffixNode(node) {\n    // Frozen node - can't change.\n    if (node._c) {\n      return node;\n    } // Make sure all children are combined and generate unique node\n    // signature for this node.\n\n\n    var sig = [];\n\n    if (this.isTerminal(node)) {\n      sig.push('!');\n    }\n\n    var props = this.nodeProps(node);\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n\n      if (_typeof(node[prop]) === 'object') {\n        node[prop] = this.combineSuffixNode(node[prop]);\n        sig.push(prop);\n        sig.push(node[prop]._c);\n      } else {\n        sig.push(prop);\n      }\n    }\n\n    sig = sig.join('-');\n    var shared = this.suffixes[sig];\n\n    if (shared) {\n      return shared;\n    }\n\n    this.suffixes[sig] = node;\n    node._c = this.cNext++;\n    return node;\n  },\n  prepDFS: function prepDFS() {\n    this.vCur++;\n  },\n  visited: function visited(node) {\n    if (node._v === this.vCur) {\n      return true;\n    }\n\n    node._v = this.vCur;\n    return false;\n  },\n  countDegree: function countDegree(node) {\n    if (node._d === undefined) {\n      node._d = 0;\n    }\n\n    node._d++;\n\n    if (this.visited(node)) {\n      return;\n    }\n\n    var props = this.nodeProps(node, true);\n\n    for (var i = 0; i < props.length; i++) {\n      this.countDegree(node[props[i]]);\n    }\n  },\n  // Remove intermediate singleton nodes by hoisting into their parent\n  collapseChains: function collapseChains(node) {\n    var prop, props, child, i;\n\n    if (this.visited(node)) {\n      return;\n    }\n\n    props = this.nodeProps(node);\n\n    for (i = 0; i < props.length; i++) {\n      prop = props[i];\n      child = node[prop];\n\n      if (_typeof(child) !== 'object') {\n        continue;\n      }\n\n      this.collapseChains(child); // Hoist the singleton child's single property to the parent\n\n      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {\n        delete node[prop];\n        prop += child._g;\n        node[prop] = child[child._g];\n      }\n    } // Identify singleton nodes\n\n\n    if (props.length === 1 && !this.isTerminal(node)) {\n      node._g = prop;\n    }\n  },\n  isTerminal: function isTerminal(node) {\n    return !!node[''];\n  },\n  // Find highest node in Trie that is on the path to word\n  // and that is NOT on the path to other.\n  uniqueNode: function uniqueNode(word, other, node) {\n    var props = this.nodeProps(node, true);\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n\n      if (prop === word.slice(0, prop.length)) {\n        if (prop !== other.slice(0, prop.length)) {\n          return node[prop];\n        }\n\n        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop]);\n      }\n    }\n\n    return undefined;\n  },\n  pack: function pack() {\n    return _pack(this);\n  }\n};\nexport default methods;","map":null,"metadata":{},"sourceType":"module"}