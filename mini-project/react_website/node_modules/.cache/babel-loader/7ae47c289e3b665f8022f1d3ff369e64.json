{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport pluckOutTerm from './lib/remove.js';\n\nvar fixPointers = function fixPointers(ptrs, gonePtrs) {\n  ptrs = ptrs.map(function (ptr) {\n    var _ptr = _slicedToArray(ptr, 1),\n        n = _ptr[0];\n\n    if (!gonePtrs[n]) {\n      return ptr;\n    }\n\n    gonePtrs[n].forEach(function (no) {\n      var len = no[2] - no[1]; // does it effect our pointer?\n\n      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {\n        ptr[2] -= len;\n      }\n    });\n    return ptr;\n  }); // decrement any pointers after a now-empty pointer\n\n  ptrs.forEach(function (ptr, i) {\n    // is the pointer now empty?\n    if (ptr[1] === 0 && ptr[2] == 0) {\n      // go down subsequent pointers\n      for (var n = i + 1; n < ptrs.length; n += 1) {\n        ptrs[n][0] -= 1;\n\n        if (ptrs[n][0] < 0) {\n          ptrs[n][0] = 0;\n        }\n      }\n    }\n  }); // remove any now-empty pointers\n\n  ptrs = ptrs.filter(function (ptr) {\n    return ptr[2] - ptr[1] > 0;\n  }); // remove old hard-pointers\n\n  ptrs = ptrs.map(function (ptr) {\n    ptr[3] = null;\n    ptr[4] = null;\n    return ptr;\n  });\n  return ptrs;\n};\n\nvar methods = {\n  /** */\n  remove: function remove(reg) {\n    var indexN = this.methods.one.pointer.indexN; // two modes:\n    //  - a. remove self, from full parent\n\n    var self = this.all();\n    var not = this; //  - b. remove a match, from self\n\n    if (reg) {\n      self = this;\n      not = this.match(reg);\n    } // is it part of a contraction?\n\n\n    if (self.has('@hasContraction') && self.contractions) {\n      var more = self.grow('@hasContraction');\n      more.contractions().expand();\n    }\n\n    var ptrs = self.fullPointer;\n    var nots = not.fullPointer.reverse(); // remove them from the actual document)\n\n    var document = pluckOutTerm(this.document, nots); // repair our pointers\n\n    var gonePtrs = indexN(nots);\n    ptrs = fixPointers(ptrs, gonePtrs); // clean up our original inputs\n\n    self.ptrs = ptrs;\n    self.document = document;\n    self.compute('index');\n\n    if (!reg) {\n      this.ptrs = [];\n      return self.none();\n    } // self._cache = null\n\n\n    var res = self.toView(ptrs); //return new document\n\n    return res;\n  }\n}; // aliases\n\nmethods.delete = methods.remove;\nexport default methods;","map":null,"metadata":{},"sourceType":"module"}