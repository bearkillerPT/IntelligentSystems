{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport failFast from './01-failFast.js';\nimport fromHere from './02-from-here.js';\nimport getGroup from './03-getGroup.js'; // make proper pointers\n\nvar addSentence = function addSentence(res, n) {\n  res.pointer[0] = n;\n  Object.keys(res.groups).forEach(function (k) {\n    res.groups[k][0] = n;\n  });\n  return res;\n};\n\nvar handleStart = function handleStart(terms, regs, n) {\n  var res = fromHere(terms, regs, 0, terms.length);\n\n  if (res) {\n    res = addSentence(res, n);\n    return res; //getGroup([res], group)\n  }\n\n  return null;\n}; // ok, here we go.\n\n\nvar runMatch = function runMatch(docs, todo, cache) {\n  cache = cache || [];\n  var regs = todo.regs,\n      group = todo.group,\n      justOne = todo.justOne;\n  var results = [];\n\n  if (!regs || regs.length === 0) {\n    return {\n      ptrs: [],\n      byGroup: {}\n    };\n  }\n\n  var minLength = regs.filter(function (r) {\n    return r.optional !== true && r.negative !== true;\n  }).length;\n\n  docs: for (var n = 0; n < docs.length; n += 1) {\n    var terms = docs[n]; // let index = terms[0].index || []\n    // can we skip this sentence?\n\n    if (cache[n] && failFast(regs, cache[n])) {\n      continue;\n    } // ^start regs only run once, per phrase\n\n\n    if (regs[0].start === true) {\n      var foundStart = handleStart(terms, regs, n, group);\n\n      if (foundStart) {\n        results.push(foundStart);\n      }\n\n      continue;\n    } //ok, try starting the match now from every term\n\n\n    for (var i = 0; i < terms.length; i += 1) {\n      var slice = terms.slice(i); // ensure it's long-enough\n\n      if (slice.length < minLength) {\n        break;\n      }\n\n      var res = fromHere(slice, regs, i, terms.length); // did we find a result?\n\n      if (res) {\n        // res = addSentence(res, index[0])\n        res = addSentence(res, n);\n        results.push(res); // should we stop here?\n\n        if (justOne === true) {\n          break docs;\n        } // skip ahead, over these results\n\n\n        var end = res.pointer[2];\n\n        if (Math.abs(end - 1) > i) {\n          i = Math.abs(end - 1);\n        }\n      }\n    }\n  } // ensure any end-results ($) match until the last term\n\n\n  if (regs[regs.length - 1].end === true) {\n    results = results.filter(function (res) {\n      var n = res.pointer[0];\n      return docs[n].length === res.pointer[2];\n    });\n  } // grab the requested group\n\n\n  results = getGroup(results, group); // add ids to pointers\n\n  results.ptrs.forEach(function (ptr) {\n    var _ptr = _slicedToArray(ptr, 3),\n        n = _ptr[0],\n        start = _ptr[1],\n        end = _ptr[2];\n\n    ptr[3] = docs[n][start].id; //start-id\n\n    ptr[4] = docs[n][end - 1].id; //end-id\n  });\n  return results;\n};\n\nexport default runMatch;","map":null,"metadata":{},"sourceType":"module"}