{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { indexN } from './_lib.js'; // split a pointer, by match pointer\n\nvar pivotBy = function pivotBy(full, m) {\n  var _full = _slicedToArray(full, 2),\n      n = _full[0],\n      start = _full[1];\n\n  var mStart = m[1];\n  var mEnd = m[2];\n  var res = {}; // is there space before the match?\n\n  if (start < mStart) {\n    var end = mStart < full[2] ? mStart : full[2]; // find closest end-point\n\n    res.before = [n, start, end]; //before segment\n  }\n\n  res.match = m; // is there space after the match?\n\n  if (full[2] > mEnd) {\n    res.after = [n, mEnd, full[2]]; //after segment\n  }\n\n  return res;\n};\n\nvar doesMatch = function doesMatch(full, m) {\n  return full[1] <= m[1] && m[2] <= full[2];\n};\n\nvar splitAll = function splitAll(full, m) {\n  var byN = indexN(m);\n  var res = [];\n  full.forEach(function (ptr) {\n    var _ptr = _slicedToArray(ptr, 1),\n        n = _ptr[0];\n\n    var matches = byN[n] || [];\n    matches = matches.filter(function (p) {\n      return doesMatch(ptr, p);\n    });\n\n    if (matches.length === 0) {\n      res.push({\n        passthrough: ptr\n      });\n      return;\n    } // ensure matches are in-order\n\n\n    matches = matches.sort(function (a, b) {\n      return a[1] - b[1];\n    }); // start splitting our left-to-right\n\n    var carry = ptr;\n    matches.forEach(function (p, i) {\n      var found = pivotBy(carry, p); // last one\n\n      if (!matches[i + 1]) {\n        res.push(found);\n      } else {\n        res.push({\n          before: found.before,\n          match: found.match\n        });\n\n        if (found.after) {\n          carry = found.after;\n        }\n      }\n    });\n  });\n  return res;\n};\n\nexport default splitAll;","map":null,"metadata":{},"sourceType":"module"}