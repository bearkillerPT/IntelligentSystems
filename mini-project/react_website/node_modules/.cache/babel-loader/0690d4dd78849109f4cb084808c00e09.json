{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n// do the pointers intersect?\nexport var doesOverlap = function doesOverlap(a, b) {\n  if (a[0] !== b[0]) {\n    return false;\n  }\n\n  var _a = _slicedToArray(a, 3),\n      startA = _a[1],\n      endA = _a[2];\n\n  var _b = _slicedToArray(b, 3),\n      startB = _b[1],\n      endB = _b[2]; // [a,a,a,-,-,-,]\n  // [-,-,b,b,b,-,]\n\n\n  if (startA <= startB && endA > startB) {\n    return true;\n  } // [-,-,-,a,a,-,]\n  // [-,-,b,b,b,-,]\n\n\n  if (startB <= startA && endB > startA) {\n    return true;\n  }\n\n  return false;\n}; // get widest min/max\n\nexport var getExtent = function getExtent(ptrs) {\n  var min = ptrs[0][1];\n  var max = ptrs[0][2];\n  ptrs.forEach(function (ptr) {\n    if (ptr[1] < min) {\n      min = ptr[1];\n    }\n\n    if (ptr[2] > max) {\n      max = ptr[2];\n    }\n  });\n  return [ptrs[0][0], min, max];\n}; // collect pointers by sentence number\n\nexport var indexN = function indexN(ptrs) {\n  var byN = {};\n  ptrs.forEach(function (ref) {\n    byN[ref[0]] = byN[ref[0]] || [];\n    byN[ref[0]].push(ref);\n  });\n  return byN;\n}; // remove exact duplicates\n\nexport var uniquePtrs = function uniquePtrs(arr) {\n  var obj = {};\n\n  for (var i = 0; i < arr.length; i += 1) {\n    obj[arr[i].join(',')] = arr[i];\n  }\n\n  return Object.values(obj);\n}; // a before b\n// console.log(doesOverlap([0, 0, 4], [0, 2, 5]))\n// // b before a\n// console.log(doesOverlap([0, 3, 4], [0, 1, 5]))\n// // disjoint\n// console.log(doesOverlap([0, 0, 3], [0, 4, 5]))\n// neighbours\n// console.log(doesOverlap([0, 1, 3], [0, 3, 5]))\n// console.log(doesOverlap([0, 3, 5], [0, 1, 3]))\n// console.log(\n//   getExtent([\n//     [0, 3, 4],\n//     [0, 4, 5],\n//     [0, 1, 2],\n//   ])\n// )","map":null,"metadata":{},"sourceType":"module"}