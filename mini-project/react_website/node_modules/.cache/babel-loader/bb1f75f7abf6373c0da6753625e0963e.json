{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport splice from './_splice.js';\nimport apostropheS from './apostrophe-s.js';\nimport apostropheD from './apostrophe-d.js';\nimport apostropheT from './apostrophe-t.js';\nimport isPossessive from './isPossessive.js';\nvar byApostrophe = /'/; // poor-mans reindexing of this sentence only\n\nvar reIndex = function reIndex(terms) {\n  terms.forEach(function (t, i) {\n    if (t.index) {\n      t.index[1] = i;\n    }\n  });\n}; // run tagger on our new implicit terms\n\n\nvar reTag = function reTag(terms, view, start, len) {\n  var tmp = view.update();\n  tmp.document = [terms]; // offer to re-tag neighbours, too\n\n  var end = start + len;\n\n  if (start > 0) {\n    start -= 1;\n  }\n\n  if (terms[end]) {\n    end += 1;\n  }\n\n  tmp.ptrs = [[0, start, end]];\n  tmp.compute(['lexicon', 'preTagger']); // don't for a reindex of the whole document\n\n  reIndex(terms);\n};\n\nvar byEnd = {\n  // how'd\n  d: function d(terms, i) {\n    return apostropheD(terms, i);\n  },\n  // we ain't\n  t: function t(terms, i) {\n    return apostropheT(terms, i);\n  },\n  // bob's\n  s: function s(terms, i, world) {\n    // [bob's house] vs [bob's cool]\n    if (isPossessive(terms, i)) {\n      return world.methods.one.setTag([terms[i]], 'Possessive', world, '2-contraction');\n    }\n\n    return apostropheS(terms, i);\n  }\n};\n\nvar toDocs = function toDocs(words, view) {\n  var doc = view.fromText(words.join(' '));\n  doc.compute('id');\n  return doc.docs[0];\n}; //really easy ones\n\n\nvar contractionTwo = function contractionTwo(view) {\n  var world = view.world,\n      document = view.document; // each sentence\n\n  document.forEach(function (terms, n) {\n    // loop through terms backwards\n    for (var i = terms.length - 1; i >= 0; i -= 1) {\n      // is it already a contraction\n      if (terms[i].implicit) {\n        return;\n      }\n\n      var after = null;\n\n      if (byApostrophe.test(terms[i].normal) === true) {\n        var _terms$i$normal$split = terms[i].normal.split(byApostrophe);\n\n        var _terms$i$normal$split2 = _slicedToArray(_terms$i$normal$split, 2);\n\n        after = _terms$i$normal$split2[1];\n      }\n\n      var words = null; // any known-ones, like 'dunno'?\n      // ['foo', 's']\n\n      if (byEnd.hasOwnProperty(after)) {\n        words = byEnd[after](terms, i, world);\n      } // actually insert the new terms\n\n\n      if (words) {\n        words = toDocs(words, view);\n        splice(document, [n, i], words);\n        reTag(document[n], view, i, words.length);\n        continue;\n      }\n    }\n  });\n};\n\nexport default {\n  contractionTwo: contractionTwo\n};","map":null,"metadata":{},"sourceType":"module"}