{"ast":null,"code":"var hasApostrophe = /['‘’‛‵′`´]/; // normal regexes\n\nvar doRegs = function doRegs(str, regs) {\n  for (var i = 0; i < regs.length; i += 1) {\n    if (regs[i][0].test(str) === true) {\n      return regs[i];\n    }\n  }\n\n  return null;\n}; // suffix-regexes, indexed by last-character\n\n\nvar doEndsWith = function doEndsWith() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var byEnd = arguments.length > 1 ? arguments[1] : undefined;\n  var char = str[str.length - 1];\n\n  if (byEnd.hasOwnProperty(char) === true) {\n    var regs = byEnd[char] || [];\n\n    for (var r = 0; r < regs.length; r += 1) {\n      if (regs[r][0].test(str) === true) {\n        return regs[r];\n      }\n    }\n  }\n\n  return null;\n};\n\nvar checkRegex = function checkRegex(terms, i, model, world) {\n  var setTag = world.methods.one.setTag;\n  var _model$two = model.two,\n      regexText = _model$two.regexText,\n      regexNormal = _model$two.regexNormal,\n      regexNumbers = _model$two.regexNumbers,\n      endsWith = _model$two.endsWith;\n  var term = terms[i];\n  var normal = term.machine || term.normal;\n  var text = term.text; // keep dangling apostrophe?\n\n  if (hasApostrophe.test(term.post) && !hasApostrophe.test(term.pre)) {\n    text += term.post.trim();\n  }\n\n  var arr = doRegs(text, regexText) || doRegs(normal, regexNormal); // hide a bunch of number regexes behind this one\n\n  if (!arr && /[0-9]/.test(normal)) {\n    arr = doRegs(normal, regexNumbers);\n  } // only run endsWith if we're desperate\n\n\n  if (!arr && term.tags.size === 0) {\n    arr = doEndsWith(normal, endsWith);\n  }\n\n  if (arr) {\n    setTag([term], arr[1], world, null, \"2-regex-'\".concat(arr[2] || arr[0], \"'\"));\n    term.confidence = 0.6;\n    return true;\n  }\n\n  return null;\n};\n\nexport default checkRegex;","map":null,"metadata":{},"sourceType":"module"}