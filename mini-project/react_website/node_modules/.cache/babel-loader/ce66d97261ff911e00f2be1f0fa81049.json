{"ast":null,"code":"import Histogram from './histogram.js';\nimport encoding from '../encoding.js';\nvar config = {\n  NODE_SEP: ';',\n  KEY_VAL: ':',\n  STRING_SEP: ',',\n  TERMINAL_PREFIX: '!',\n  BASE: 36\n}; // Return packed representation of Trie as a string.\n// Return packed representation of Trie as a string.\n//\n// Each node of the Trie is output on a single line.\n//\n// For example Trie(\"the them there thesis this\"):\n// {\n//    \"th\": {\n//      \"is\": 1,\n//      \"e\": {\n//        \"\": 1,\n//        \"m\": 1,\n//        \"re\": 1,\n//        \"sis\": 1\n//      }\n//    }\n//  }\n//\n// Would be reperesented as:\n//\n// th0\n// e0is\n// !m,re,sis\n//\n// The line begins with a '!' iff it is a terminal node of the Trie.\n// For each string property in a node, the string is listed, along\n// with a (relative!) line number of the node that string references.\n// Terminal strings (those without child node references) are\n// separated by ',' characters.\n\nvar nodeLine = function nodeLine(self, node) {\n  var line = '',\n      sep = '';\n\n  if (self.isTerminal(node)) {\n    line += config.TERMINAL_PREFIX;\n  }\n\n  var props = self.nodeProps(node);\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n\n    if (typeof node[prop] === 'number') {\n      line += sep + prop;\n      sep = config.STRING_SEP;\n      continue;\n    }\n\n    if (self.syms[node[prop]._n]) {\n      line += sep + prop + self.syms[node[prop]._n];\n      sep = '';\n      continue;\n    }\n\n    var ref = encoding.toAlphaCode(node._n - node[prop]._n - 1 + self.symCount); // Large reference to smaller string suffix -> duplicate suffix\n\n    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {\n      ref = node[prop]._g;\n      line += sep + prop + ref;\n      sep = config.STRING_SEP;\n      continue;\n    }\n\n    line += sep + prop + ref;\n    sep = '';\n  }\n\n  return line;\n};\n\nvar analyzeRefs = function analyzeRefs(self, node) {\n  if (self.visited(node)) {\n    return;\n  }\n\n  var props = self.nodeProps(node, true);\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var ref = node._n - node[prop]._n - 1; // Count the number of single-character relative refs\n\n    if (ref < config.BASE) {\n      self.histRel.add(ref);\n    } // Count the number of characters saved by converting an absolute\n    // reference to a one-character symbol.\n\n\n    self.histAbs.add(node[prop]._n, encoding.toAlphaCode(ref).length - 1);\n    analyzeRefs(self, node[prop]);\n  }\n};\n\nvar symbolCount = function symbolCount(self) {\n  self.histAbs = self.histAbs.highest(config.BASE);\n  var savings = [];\n  savings[-1] = 0;\n  var best = 0,\n      sCount = 0;\n  var defSize = 3 + encoding.toAlphaCode(self.nodeCount).length;\n\n  for (var sym = 0; sym < config.BASE; sym++) {\n    if (self.histAbs[sym] === undefined) {\n      break;\n    }\n\n    savings[sym] = self.histAbs[sym][1] - defSize - self.histRel.countOf(config.BASE - sym - 1) + savings[sym - 1];\n\n    if (savings[sym] >= best) {\n      best = savings[sym];\n      sCount = sym + 1;\n    }\n  }\n\n  return sCount;\n};\n\nvar numberNodes = function numberNodes(self, node) {\n  // Topological sort into nodes array\n  if (node._n !== undefined) {\n    return;\n  }\n\n  var props = self.nodeProps(node, true);\n\n  for (var i = 0; i < props.length; i++) {\n    numberNodes(self, node[props[i]]); //recursive\n  }\n\n  node._n = self.pos++;\n  self.nodes.unshift(node);\n};\n\nvar pack = function pack(self) {\n  self.nodes = [];\n  self.nodeCount = 0;\n  self.syms = {};\n  self.symCount = 0;\n  self.pos = 0; // Make sure we've combined all the common suffixes\n\n  self.optimize();\n  self.histAbs = new Histogram();\n  self.histRel = new Histogram();\n  numberNodes(self, self.root);\n  self.nodeCount = self.nodes.length;\n  self.prepDFS();\n  analyzeRefs(self, self.root);\n  self.symCount = symbolCount(self);\n\n  for (var sym = 0; sym < self.symCount; sym++) {\n    self.syms[self.histAbs[sym][0]] = encoding.toAlphaCode(sym);\n  }\n\n  for (var i = 0; i < self.nodeCount; i++) {\n    self.nodes[i] = nodeLine(self, self.nodes[i]);\n  } // Prepend symbols\n\n\n  for (var _sym = self.symCount - 1; _sym >= 0; _sym--) {\n    self.nodes.unshift(encoding.toAlphaCode(_sym) + config.KEY_VAL + encoding.toAlphaCode(self.nodeCount - self.histAbs[_sym][0] - 1));\n  }\n\n  return self.nodes.join(config.NODE_SEP);\n};\n\nexport default pack;","map":null,"metadata":{},"sourceType":"module"}