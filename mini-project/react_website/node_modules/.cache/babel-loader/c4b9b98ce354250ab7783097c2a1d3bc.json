{"ast":null,"code":"import { fixPointers, isView, isNet } from './_lib.js';\n\nvar match = function match(regs, group, opts) {\n  var one = this.methods.one; // support param as view object\n\n  if (isView(regs)) {\n    return this.intersection(regs);\n  } // support a compiled set of matches\n\n\n  if (isNet(regs)) {\n    return this.sweep(regs, {\n      tagger: false\n    }).view.settle();\n  } // support param as string\n\n\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, this.world);\n    regs = one.parseMatch(regs, opts, this.world);\n  }\n\n  var todo = {\n    regs: regs,\n    group: group\n  };\n  var res = one.match(this.docs, todo, this._cache);\n\n  var _fixPointers = fixPointers(res, this.fullPointer),\n      ptrs = _fixPointers.ptrs,\n      byGroup = _fixPointers.byGroup;\n\n  var view = this.toView(ptrs);\n  view._groups = byGroup; // try to keep some of the cache\n  // if (this._cache) {\n  //   view._cache = view.ptrs.map(ptr => {\n  //     if (isFull(ptr, this.document)) {\n  //       return this._cache[ptr[0]]\n  //     }\n  //     return null\n  //   })\n  // }\n\n  return view;\n};\n\nvar matchOne = function matchOne(regs, group, opts) {\n  var one = this.methods.one; // support at view as a param\n\n  if (isView(regs)) {\n    return this.intersection(regs).eq(0);\n  } // support a compiled set of matches\n\n\n  if (isNet(regs)) {\n    return this.sweep(regs, {\n      tagger: false,\n      matchOne: true\n    }).view;\n  }\n\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, this.world);\n    regs = one.parseMatch(regs, opts, this.world);\n  }\n\n  var todo = {\n    regs: regs,\n    group: group,\n    justOne: true\n  };\n  var res = one.match(this.docs, todo, this._cache);\n\n  var _fixPointers2 = fixPointers(res, this.fullPointer),\n      ptrs = _fixPointers2.ptrs,\n      byGroup = _fixPointers2.byGroup;\n\n  var view = this.toView(ptrs);\n  view._groups = byGroup;\n  return view;\n};\n\nvar has = function has(regs, group, opts) {\n  var one = this.methods.one; // support view as input\n\n  if (isView(regs)) {\n    var _ptrs = regs.fullPointer; // support a view object as input\n\n    return _ptrs.length > 0;\n  } // support a compiled set of matches\n\n\n  if (isNet(regs)) {\n    return this.sweep(regs, {\n      tagger: false\n    }).view.found;\n  }\n\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, this.world);\n    regs = one.parseMatch(regs, opts, this.world);\n  }\n\n  var todo = {\n    regs: regs,\n    group: group,\n    justOne: true\n  };\n  var ptrs = one.match(this.docs, todo, this._cache).ptrs;\n  return ptrs.length > 0;\n}; // 'if'\n\n\nvar ifFn = function ifFn(regs, group, opts) {\n  var _this = this;\n\n  var one = this.methods.one; // support view as input\n\n  if (isView(regs)) {\n    return this.filter(function (m) {\n      return m.intersection(regs).found;\n    });\n  } // support a compiled set of matches\n\n\n  if (isNet(regs)) {\n    var m = this.sweep(regs, {\n      tagger: false\n    }).view.settle();\n    return this.if(m); //recurse with result\n  }\n\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, this.world);\n    regs = one.parseMatch(regs, opts, this.world);\n  }\n\n  var todo = {\n    regs: regs,\n    group: group,\n    justOne: true\n  };\n  var ptrs = this.fullPointer;\n  var cache = this._cache || [];\n  ptrs = ptrs.filter(function (ptr, i) {\n    var m = _this.update([ptr]);\n\n    var res = one.match(m.docs, todo, cache[i]).ptrs;\n    return res.length > 0;\n  });\n  var view = this.update(ptrs); // try and reconstruct the cache\n\n  if (this._cache) {\n    view._cache = ptrs.map(function (ptr) {\n      return cache[ptr[0]];\n    });\n  }\n\n  return view;\n};\n\nvar ifNo = function ifNo(regs, group, opts) {\n  var methods = this.methods;\n  var one = methods.one; // support a view object as input\n\n  if (isView(regs)) {\n    return this.filter(function (m) {\n      return !m.intersection(regs).found;\n    });\n  } // support a compiled set of matches\n\n\n  if (isNet(regs)) {\n    var m = this.sweep(regs, {\n      tagger: false\n    }).view.settle();\n    return this.ifNo(m);\n  } // otherwise parse the match string\n\n\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, this.world);\n    regs = one.parseMatch(regs, opts, this.world);\n  }\n\n  var cache = this._cache || [];\n  var view = this.filter(function (m, i) {\n    var todo = {\n      regs: regs,\n      group: group,\n      justOne: true\n    };\n    var ptrs = one.match(m.docs, todo, cache[i]).ptrs;\n    return ptrs.length === 0;\n  }); // try to reconstruct the cache\n\n  if (this._cache) {\n    view._cache = view.ptrs.map(function (ptr) {\n      return cache[ptr[0]];\n    });\n  }\n\n  return view;\n};\n\nexport default {\n  matchOne: matchOne,\n  match: match,\n  has: has,\n  if: ifFn,\n  ifNo: ifNo\n};","map":null,"metadata":{},"sourceType":"module"}