{"ast":null,"code":"var isMulti = / /;\n\nvar addChunk = function addChunk(term, tag) {\n  if (tag === 'Noun') {\n    term.chunk = tag;\n  }\n\n  if (tag === 'Verb') {\n    term.chunk = tag;\n  }\n};\n\nvar tagTerm = function tagTerm(term, tag, tagSet, isSafe) {\n  // does it already have this tag?\n  if (term.tags.has(tag) === true) {\n    return null;\n  } // allow this shorthand in multiple-tag strings\n\n\n  if (tag === '.') {\n    return null;\n  } // for known tags, do logical dependencies first\n\n\n  var known = tagSet[tag];\n\n  if (known) {\n    // first, we remove any conflicting tags\n    if (known.not && known.not.length > 0) {\n      for (var o = 0; o < known.not.length; o += 1) {\n        // if we're in tagSafe, skip this term.\n        if (isSafe === true && term.tags.has(known.not[o])) {\n          return null;\n        }\n\n        term.tags.delete(known.not[o]);\n      }\n    } // add parent tags\n\n\n    if (known.parents && known.parents.length > 0) {\n      for (var _o = 0; _o < known.parents.length; _o += 1) {\n        term.tags.add(known.parents[_o]);\n        addChunk(term, known.parents[_o]);\n      }\n    }\n  } // finally, add our tag\n\n\n  term.tags.add(tag); // now it's dirty\n\n  term.dirty = true; // add a chunk too, if it's easy\n\n  addChunk(term, tag);\n  return true;\n}; // support '#Noun . #Adjective' syntax\n\n\nvar multiTag = function multiTag(terms, tagString, tagSet, isSafe) {\n  var tags = tagString.split(isMulti);\n  terms.forEach(function (term, i) {\n    var tag = tags[i];\n\n    if (tag) {\n      tag = tag.replace(/^#/, '');\n      tagTerm(term, tag, tagSet, isSafe);\n    }\n  });\n};\n\nvar isArray = function isArray(arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n}; // verbose-mode tagger debuging\n\n\nvar log = function log(terms, tag) {\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  var yellow = function yellow(str) {\n    return '\\x1b[33m\\x1b[3m' + str + '\\x1b[0m';\n  };\n\n  var i = function i(str) {\n    return '\\x1b[3m' + str + '\\x1b[0m';\n  };\n\n  var word = terms.map(function (t) {\n    return t.text || '[' + t.implicit + ']';\n  }).join(' ');\n\n  if (typeof tag !== 'string' && tag.length > 2) {\n    tag = tag.slice(0, 2).join(', #') + ' +'; //truncate the list of tags\n  }\n\n  tag = typeof tag !== 'string' ? tag.join(', #') : tag;\n  console.log(\" \".concat(yellow(word).padEnd(24), \" \\x1B[32m\\u2192\\x1B[0m #\").concat(tag.padEnd(22), \"  \").concat(i(reason))); // eslint-disable-line\n}; // add a tag to all these terms\n\n\nvar setTag = function setTag(terms, tag) {\n  var world = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isSafe = arguments.length > 3 ? arguments[3] : undefined;\n  var reason = arguments.length > 4 ? arguments[4] : undefined;\n  var tagSet = world.model.one.tagSet || {};\n\n  if (!tag) {\n    return;\n  } // some logging for debugging\n\n\n  var env = typeof process === 'undefined' || !process.env ? self.env || {} : process.env;\n\n  if (env && env.DEBUG_TAGS) {\n    log(terms, tag, reason);\n  }\n\n  if (isArray(tag) === true) {\n    tag.forEach(function (tg) {\n      return setTag(terms, tg, world, isSafe);\n    });\n    return;\n  }\n\n  tag = tag.trim(); // support '#Noun . #Adjective' syntax\n\n  if (isMulti.test(tag)) {\n    multiTag(terms, tag, tagSet, isSafe);\n    return;\n  }\n\n  tag = tag.replace(/^#/, ''); // let set = false\n\n  for (var i = 0; i < terms.length; i += 1) {\n    tagTerm(terms[i], tag, tagSet, isSafe);\n  }\n};\n\nexport default setTag;","map":null,"metadata":{},"sourceType":"module"}