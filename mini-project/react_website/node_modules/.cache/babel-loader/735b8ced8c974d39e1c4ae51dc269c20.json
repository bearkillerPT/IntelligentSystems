{"ast":null,"code":"import View from './API/View.js';\nimport tmpWrld from './API/world.js';\nimport version from './_version.js';\nimport extend from './API/extend.js';\nimport { verbose } from './API/_lib.js';\nimport handleInputs from './API/inputs.js';\nvar world = Object.assign({}, tmpWrld);\n\nvar nlp = function nlp(input, lex) {\n  if (lex) {\n    nlp.addWords(lex);\n  }\n\n  var doc = handleInputs(input, View, world);\n\n  if (input) {\n    doc.compute(world.hooks);\n  }\n\n  return doc;\n};\n\nObject.defineProperty(nlp, '_world', {\n  value: world,\n  writable: true\n});\n/** don't run the POS-tagger */\n\nnlp.tokenize = function (input, lex) {\n  var compute = this._world.compute; // add user-given words to lexicon\n\n  if (lex) {\n    nlp.addWords(lex);\n  } // run the tokenizer\n\n\n  var doc = handleInputs(input, View, world); // give contractions a shot, at least\n\n  if (compute.contractions) {\n    doc.compute(['alias', 'normal', 'machine', 'contractions']); //run it if we've got it\n  }\n\n  return doc;\n};\n/** extend compromise functionality */\n\n\nnlp.plugin = function (plugin) {\n  extend(plugin, this._world, View, this);\n  return this;\n};\n\nnlp.extend = nlp.plugin;\n/** reach-into compromise internals */\n\nnlp.world = function () {\n  return this._world;\n};\n\nnlp.model = function () {\n  return this._world.model;\n};\n\nnlp.methods = function () {\n  return this._world.methods;\n};\n\nnlp.hooks = function () {\n  return this._world.hooks;\n};\n/** log the decision-making to console */\n\n\nnlp.verbose = verbose;\n/** current library release version */\n\nnlp.version = version;\nexport default nlp;","map":null,"metadata":{},"sourceType":"module"}