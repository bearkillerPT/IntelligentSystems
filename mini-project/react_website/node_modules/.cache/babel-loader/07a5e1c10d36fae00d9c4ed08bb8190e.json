{"ast":null,"code":"import findModifiers from './findModifiers.js';\nimport words from './data.js';\nimport isValid from './validate.js';\nimport parseDecimals from './parseDecimals.js';\nimport parseNumeric from './parseNumeric.js';\nvar improperFraction = /^([0-9,. ]+)\\/([0-9,. ]+)$/; //some numbers we know\n\nvar casualForms = {\n  'a few': 3,\n  'a couple': 2,\n  'a dozen': 12,\n  'two dozen': 24,\n  zero: 0\n}; // a 'section' is something like 'fifty-nine thousand'\n// turn a section into something we can add to - like 59000\n\nvar section_sum = function section_sum(obj) {\n  return Object.keys(obj).reduce(function (sum, k) {\n    sum += obj[k];\n    return sum;\n  }, 0);\n}; //turn a string into a number\n\n\nvar parse = function parse(str) {\n  //convert some known-numbers\n  if (casualForms.hasOwnProperty(str) === true) {\n    return casualForms[str];\n  } //'a/an' is 1\n\n\n  if (str === 'a' || str === 'an') {\n    return 1;\n  }\n\n  var modifier = findModifiers(str);\n  str = modifier.str;\n  var last_mult = null;\n  var has = {};\n  var sum = 0;\n  var isNegative = false;\n  var terms = str.split(/[ -]/); // const isFraction = findFraction(terms)\n\n  for (var i = 0; i < terms.length; i++) {\n    var w = terms[i];\n    w = parseNumeric(w);\n\n    if (!w || w === 'and') {\n      continue;\n    }\n\n    if (w === '-' || w === 'negative') {\n      isNegative = true;\n      continue;\n    }\n\n    if (w.charAt(0) === '-') {\n      isNegative = true;\n      w = w.substring(1);\n    } //decimal mode\n\n\n    if (w === 'point') {\n      sum += section_sum(has);\n      sum += parseDecimals(terms.slice(i + 1, terms.length));\n      sum *= modifier.amount;\n      return sum;\n    } //improper fraction\n\n\n    var fm = w.match(improperFraction);\n\n    if (fm) {\n      var num = parseFloat(fm[1].replace(/[, ]/g, ''));\n      var denom = parseFloat(fm[2].replace(/[, ]/g, ''));\n\n      if (denom) {\n        sum += num / denom || 0;\n      }\n\n      continue;\n    } // try to support 'two fifty'\n\n\n    if (words.tens.hasOwnProperty(w)) {\n      if (has.ones && Object.keys(has).length === 1) {\n        sum = has.ones * 100;\n        has = {};\n      }\n    } //prevent mismatched units, like 'seven eleven' if not a fraction\n\n\n    if (isValid(w, has) === false) {\n      return null;\n    } //buildOut section, collect 'has' values\n\n\n    if (/^[0-9.]+$/.test(w)) {\n      has.ones = parseFloat(w); //not technically right\n    } else if (words.ones.hasOwnProperty(w) === true) {\n      has.ones = words.ones[w];\n    } else if (words.teens.hasOwnProperty(w) === true) {\n      has.teens = words.teens[w];\n    } else if (words.tens.hasOwnProperty(w) === true) {\n      has.tens = words.tens[w];\n    } else if (words.multiples.hasOwnProperty(w) === true) {\n      var mult = words.multiples[w]; //something has gone wrong : 'two hundred five hundred'\n      //possibly because it's a fraction\n\n      if (mult === last_mult) {\n        return null;\n      } //support 'hundred thousand'\n      //this one is tricky..\n\n\n      if (mult === 100 && terms[i + 1] !== undefined) {\n        var w2 = terms[i + 1];\n\n        if (words.multiples[w2]) {\n          mult *= words.multiples[w2]; //hundredThousand/hundredMillion\n\n          i += 1;\n        }\n      } //natural order of things\n      //five thousand, one hundred..\n\n\n      if (last_mult === null || mult < last_mult) {\n        sum += (section_sum(has) || 1) * mult;\n        last_mult = mult;\n        has = {};\n      } else {\n        //maybe hundred .. thousand\n        sum += section_sum(has);\n        last_mult = mult;\n        sum = (sum || 1) * mult;\n        has = {};\n      }\n    }\n  } //dump the remaining has values\n\n\n  sum += section_sum(has); //post-process add modifier\n\n  sum *= modifier.amount;\n  sum *= isNegative ? -1 : 1; //dont return 0, if it went straight-through\n\n  if (sum === 0 && Object.keys(has).length === 0) {\n    return null;\n  }\n\n  return sum;\n};\n\nexport default parse;","map":null,"metadata":{},"sourceType":"module"}