{"ast":null,"code":"var hasMinMax = /\\{([0-9]+)?(, *[0-9]*)?\\}/;\nvar andSign = /&&/; // const hasDash = /\\p{Letter}[-–—]\\p{Letter}/u\n\nvar captureName = new RegExp(/^<\\s*(\\S+)\\s*>/);\n/* break-down a match expression into this:\n{\n  word:'',\n  tag:'',\n  regex:'',\n\n  start:false,\n  end:false,\n  negative:false,\n  anything:false,\n  greedy:false,\n  optional:false,\n\n  named:'',\n  choices:[],\n}\n*/\n\nvar titleCase = function titleCase(str) {\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar end = function end(str) {\n  return str.charAt(str.length - 1);\n};\n\nvar start = function start(str) {\n  return str.charAt(0);\n};\n\nvar stripStart = function stripStart(str) {\n  return str.substring(1);\n};\n\nvar stripEnd = function stripEnd(str) {\n  return str.substring(0, str.length - 1);\n};\n\nvar stripBoth = function stripBoth(str) {\n  str = stripStart(str);\n  str = stripEnd(str);\n  return str;\n}; //\n\n\nvar parseToken = function parseToken(w, opts) {\n  var obj = {}; //collect any flags (do it twice)\n\n  for (var i = 0; i < 2; i += 1) {\n    //end-flag\n    if (end(w) === '$') {\n      obj.end = true;\n      w = stripEnd(w);\n    } //front-flag\n\n\n    if (start(w) === '^') {\n      obj.start = true;\n      w = stripStart(w);\n    } //capture group (this one can span multiple-terms)\n\n\n    if (start(w) === '[' || end(w) === ']') {\n      obj.group = null;\n\n      if (start(w) === '[') {\n        obj.groupStart = true;\n      }\n\n      if (end(w) === ']') {\n        obj.groupEnd = true;\n      }\n\n      w = w.replace(/^\\[/, '');\n      w = w.replace(/\\]$/, ''); // Use capture group name\n\n      if (start(w) === '<') {\n        var res = captureName.exec(w);\n\n        if (res.length >= 2) {\n          obj.group = res[1];\n          w = w.replace(res[0], '');\n        }\n      }\n    } //back-flags\n\n\n    if (end(w) === '+') {\n      obj.greedy = true;\n      w = stripEnd(w);\n    }\n\n    if (w !== '*' && end(w) === '*' && w !== '\\\\*') {\n      obj.greedy = true;\n      w = stripEnd(w);\n    }\n\n    if (end(w) === '?') {\n      obj.optional = true;\n      w = stripEnd(w);\n    }\n\n    if (start(w) === '!') {\n      obj.negative = true; // obj.optional = true\n\n      w = stripStart(w);\n    } //soft-match\n\n\n    if (start(w) === '~' && end(w) === '~' && w.length > 2) {\n      w = stripBoth(w);\n      obj.fuzzy = true;\n      obj.min = opts.fuzzy || 0.85;\n\n      if (/\\(/.test(w) === false) {\n        obj.word = w;\n        return obj;\n      }\n    } //wrapped-flags\n\n\n    if (start(w) === '(' && end(w) === ')') {\n      // support (one && two)\n      if (andSign.test(w)) {\n        obj.choices = w.split(andSign);\n        obj.operator = 'and';\n      } else {\n        obj.choices = w.split('|');\n        obj.operator = 'or';\n      } //remove '(' and ')'\n\n\n      obj.choices[0] = stripStart(obj.choices[0]);\n      var last = obj.choices.length - 1;\n      obj.choices[last] = stripEnd(obj.choices[last]); // clean up the results\n\n      obj.choices = obj.choices.map(function (s) {\n        return s.trim();\n      });\n      obj.choices = obj.choices.filter(function (s) {\n        return s;\n      }); //recursion alert!\n\n      obj.choices = obj.choices.map(function (str) {\n        return str.split(/ /g).map(function (s) {\n          return parseToken(s, opts);\n        });\n      });\n      w = '';\n    } //regex\n\n\n    if (start(w) === '/' && end(w) === '/') {\n      w = stripBoth(w);\n\n      if (opts.caseSensitive) {\n        obj.use = 'text';\n      }\n\n      obj.regex = new RegExp(w); //potential vuln - security/detect-non-literal-regexp\n\n      return obj;\n    } //machine/sense overloaded\n\n\n    if (start(w) === '{' && end(w) === '}') {\n      w = stripBoth(w);\n\n      if (/\\//.test(w)) {\n        obj.sense = w;\n        obj.greedy = true;\n      } else {\n        obj.machine = w;\n      }\n\n      return obj;\n    } //chunks\n\n\n    if (start(w) === '<' && end(w) === '>') {\n      w = stripBoth(w);\n      obj.chunk = titleCase(w);\n      obj.greedy = true;\n      return obj;\n    }\n\n    if (start(w) === '%' && end(w) === '%') {\n      w = stripBoth(w);\n      obj.switch = w;\n      return obj;\n    }\n  } // support foo{1,9}\n\n\n  if (hasMinMax.test(w) === true) {\n    w = w.replace(hasMinMax, function (_a, b, c) {\n      if (c === undefined) {\n        // '{3}'\tExactly three times\n        obj.min = Number(b);\n        obj.max = Number(b);\n      } else {\n        c = c.replace(/, */, '');\n\n        if (b === undefined) {\n          // '{,9}' implied zero min\n          obj.min = 0;\n          obj.max = Number(c);\n        } else {\n          // '{2,4}' Two to four times\n          obj.min = Number(b); // '{3,}' Three or more times\n\n          obj.max = Number(c || 999);\n        }\n      } // use same method as '+'\n\n\n      obj.greedy = true; // 0 as min means the same as '?'\n\n      if (!obj.min) {\n        obj.optional = true;\n      }\n\n      return '';\n    });\n  } //do the actual token content\n\n\n  if (start(w) === '#') {\n    obj.tag = stripStart(w);\n    obj.tag = titleCase(obj.tag);\n    return obj;\n  } //dynamic function on a term object\n\n\n  if (start(w) === '@') {\n    obj.method = stripStart(w);\n    return obj;\n  }\n\n  if (w === '.') {\n    obj.anything = true;\n    return obj;\n  } //support alone-astrix\n\n\n  if (w === '*') {\n    obj.anything = true;\n    obj.greedy = true;\n    obj.optional = true;\n    return obj;\n  }\n\n  if (w) {\n    //somehow handle encoded-chars?\n    w = w.replace('\\\\*', '*');\n    w = w.replace('\\\\.', '.');\n\n    if (opts.caseSensitive) {\n      obj.use = 'text';\n    } else {\n      w = w.toLowerCase();\n    }\n\n    obj.word = w;\n  }\n\n  return obj;\n};\n\nexport default parseToken;","map":null,"metadata":{},"sourceType":"module"}