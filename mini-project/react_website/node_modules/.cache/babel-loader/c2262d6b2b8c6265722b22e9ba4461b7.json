{"ast":null,"code":"var endS = /s$/;\nimport parseText from '../numbers/parse/toNumber/index.js'; // just using .toNumber() again may risk an infinite-loop\n\nvar parseNumber = function parseNumber(m) {\n  var str = m.text('reduced');\n  return parseText(str);\n};\n\nvar mapping = {\n  half: 2,\n  halve: 2,\n  quarter: 4\n};\n\nvar slashForm = function slashForm(m) {\n  var str = m.text('reduced');\n  var found = str.match(/^([-+]?[0-9]+)\\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);\n\n  if (found && found[1] && found[0]) {\n    return {\n      numerator: Number(found[1]),\n      denominator: Number(found[2])\n    };\n  }\n\n  return null;\n}; // parse '4 out of 4'\n\n\nvar nOutOfN = function nOutOfN(m) {\n  var found = m.match('[<num>#Value+] out of every? [<den>#Value+]');\n\n  if (found.found !== true) {\n    return null;\n  }\n\n  var _found$groups = found.groups(),\n      num = _found$groups.num,\n      den = _found$groups.den;\n\n  if (!num || !den) {\n    return null;\n  }\n\n  num = parseNumber(num);\n  den = parseNumber(den);\n\n  if (!num || !den) {\n    return null;\n  }\n\n  if (typeof num === 'number' && typeof den === 'number') {\n    return {\n      numerator: num,\n      denominator: den\n    };\n  }\n\n  return null;\n}; // parse 'five thirds'\n\n\nvar nOrinalth = function nOrinalth(m) {\n  var found = m.match('[<num>(#Cardinal|a)+] [<den>#Fraction+]');\n\n  if (found.found !== true) {\n    return null;\n  }\n\n  var _found$groups2 = found.groups(),\n      num = _found$groups2.num,\n      den = _found$groups2.den; // -- parse numerator---\n  // quick-support for 'a third'\n\n\n  if (num.has('a')) {\n    num = 1;\n  } else {\n    // abuse the number-parser for 'thirty three'\n    // let tmp = num.clone().unTag('Fraction')\n    // num = tmp.numbers().get()[0]\n    num = parseNumber(num);\n  } // -- parse denominator --\n  // turn 'thirds' into third\n\n\n  var str = den.text('reduced');\n\n  if (endS.test(str)) {\n    str = str.replace(endS, '');\n    den = den.replaceWith(str);\n  } // support 'one half' as '1/2'\n\n\n  if (mapping.hasOwnProperty(str)) {\n    den = mapping[str];\n  } else {\n    // dem = dem.numbers().get()[0]\n    den = parseNumber(den);\n  }\n\n  if (typeof num === 'number' && typeof den === 'number') {\n    return {\n      numerator: num,\n      denominator: den\n    };\n  }\n\n  return null;\n}; // implied 1 in '100th of a', 'fifth of a'\n\n\nvar oneNth = function oneNth(m) {\n  var found = m.match('^#Ordinal$');\n\n  if (found.found !== true) {\n    return null;\n  } // ensure it's '100th of a '\n\n\n  if (m.lookAhead('^of .')) {\n    // let num = found.numbers().get()[0]\n    var num = parseNumber(found);\n    return {\n      numerator: 1,\n      denominator: num\n    };\n  }\n\n  return null;\n}; // 'half'\n\n\nvar named = function named(m) {\n  var str = m.text('reduced');\n\n  if (mapping.hasOwnProperty(str)) {\n    return {\n      numerator: 1,\n      denominator: mapping[str]\n    };\n  }\n\n  return null;\n};\n\nvar round = function round(n) {\n  var rounded = Math.round(n * 1000) / 1000; // don't round 1 millionth down into 0\n\n  if (rounded === 0 && n !== 0) {\n    return n;\n  }\n\n  return rounded;\n};\n\nvar parseFraction = function parseFraction(m) {\n  m = m.clone();\n  var res = named(m) || slashForm(m) || nOutOfN(m) || nOrinalth(m) || oneNth(m) || null;\n\n  if (res !== null) {\n    // do the math\n    if (res.numerator && res.denominator) {\n      res.decimal = res.numerator / res.denominator;\n      res.decimal = round(res.decimal);\n    }\n  }\n\n  return res;\n};\n\nexport default parseFraction;","map":null,"metadata":{},"sourceType":"module"}