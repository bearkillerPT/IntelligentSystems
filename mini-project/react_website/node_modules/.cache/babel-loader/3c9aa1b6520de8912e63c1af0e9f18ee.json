{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar max = 4; // sweep-around looking for our start term uuid\n\nvar blindSweep = function blindSweep(id, doc, n) {\n  for (var i = 0; i < max; i += 1) {\n    // look up a sentence\n    if (doc[n - i]) {\n      var index = doc[n - i].findIndex(function (term) {\n        return term.id === id;\n      });\n\n      if (index !== -1) {\n        return [n - i, index];\n      }\n    } // look down a sentence\n\n\n    if (doc[n + i]) {\n      var _index = doc[n + i].findIndex(function (term) {\n        return term.id === id;\n      });\n\n      if (_index !== -1) {\n        return [n + i, _index];\n      }\n    }\n  }\n\n  return null;\n};\n\nvar repairEnding = function repairEnding(ptr, document) {\n  var _ptr = _slicedToArray(ptr, 5),\n      n = _ptr[0],\n      start = _ptr[1],\n      endId = _ptr[4];\n\n  var terms = document[n]; // look for end-id\n\n  var newEnd = terms.findIndex(function (t) {\n    return t.id === endId;\n  });\n\n  if (newEnd === -1) {\n    // if end-term wasn't found, so go all the way to the end\n    ptr[2] = document[n].length;\n    ptr[4] = terms.length ? terms[terms.length - 1].id : null;\n  } else {\n    ptr[2] = newEnd; // repair ending pointer\n  }\n\n  return document[n].slice(start, ptr[2] + 1);\n};\n/** return a subset of the document, from a pointer */\n\n\nvar getDoc = function getDoc(ptrs, document) {\n  var doc = [];\n  ptrs.forEach(function (ptr, i) {\n    if (!ptr) {\n      return;\n    }\n\n    var _ptr2 = _slicedToArray(ptr, 5),\n        n = _ptr2[0],\n        start = _ptr2[1],\n        end = _ptr2[2],\n        id = _ptr2[3],\n        endId = _ptr2[4]; //parsePointer(ptr)\n\n\n    var terms = document[n] || [];\n\n    if (start === undefined) {\n      start = 0;\n    }\n\n    if (end === undefined) {\n      end = terms.length;\n    }\n\n    if (id && (!terms[start] || terms[start].id !== id)) {\n      // console.log('  repairing pointer...')\n      var wild = blindSweep(id, document, n);\n\n      if (wild !== null) {\n        var len = end - start;\n        terms = document[wild[0]].slice(wild[1], wild[1] + len); // actually change the pointer\n\n        var startId = terms[0] ? terms[0].id : null;\n        ptrs[i] = [wild[0], wild[1], wild[1] + len, startId];\n      }\n    } else {\n      terms = terms.slice(start, end);\n    }\n\n    if (terms.length === 0) {\n      return;\n    }\n\n    if (start === end) {\n      return;\n    } // test end-id, if it exists\n\n\n    if (endId && terms[terms.length - 1].id !== endId) {\n      terms = repairEnding(ptr, document);\n    } // otherwise, looks good!\n\n\n    doc.push(terms);\n  });\n  doc = doc.filter(function (a) {\n    return a.length > 0;\n  });\n  return doc;\n};\n\nexport default getDoc;","map":null,"metadata":{},"sourceType":"module"}