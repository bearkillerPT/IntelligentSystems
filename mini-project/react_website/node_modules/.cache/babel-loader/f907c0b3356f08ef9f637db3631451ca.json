{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nvar before = function before(regs, group, opts) {\n  var indexN = this.methods.one.pointer.indexN;\n  var pre = [];\n  var byN = indexN(this.fullPointer);\n  Object.keys(byN).forEach(function (k) {\n    // check only the earliest match in the sentence\n    var first = byN[k].sort(function (a, b) {\n      return a[1] > b[1] ? 1 : -1;\n    })[0];\n\n    if (first[1] > 0) {\n      pre.push([first[0], 0, first[1]]);\n    }\n  });\n  var preWords = this.toView(pre);\n\n  if (!regs) {\n    return preWords;\n  }\n\n  return preWords.match(regs, group, opts);\n};\n\nvar after = function after(regs, group, opts) {\n  var indexN = this.methods.one.pointer.indexN;\n  var post = [];\n  var byN = indexN(this.fullPointer);\n  var document = this.document;\n  Object.keys(byN).forEach(function (k) {\n    // check only the latest match in the sentence\n    var last = byN[k].sort(function (a, b) {\n      return a[1] > b[1] ? -1 : 1;\n    })[0];\n\n    var _last = _slicedToArray(last, 3),\n        n = _last[0],\n        end = _last[2];\n\n    if (end < document[n].length) {\n      post.push([n, end, document[n].length]);\n    }\n  });\n  var postWords = this.toView(post);\n\n  if (!regs) {\n    return postWords;\n  }\n\n  return postWords.match(regs, group, opts);\n};\n\nvar growLeft = function growLeft(regs, group, opts) {\n  if (typeof regs === 'string') {\n    regs = this.world.methods.one.parseMatch(regs, opts, this.world);\n  }\n\n  regs[regs.length - 1].end = true; // ensure matches are beside us ←\n\n  var ptrs = this.fullPointer;\n  this.forEach(function (m, n) {\n    var more = m.before(regs, group);\n\n    if (more.found) {\n      var terms = more.terms();\n      ptrs[n][1] -= terms.length;\n      ptrs[n][3] = terms.docs[0][0].id;\n    }\n  });\n  return this.update(ptrs);\n};\n\nvar growRight = function growRight(regs, group, opts) {\n  if (typeof regs === 'string') {\n    regs = this.world.methods.one.parseMatch(regs, opts, this.world);\n  }\n\n  regs[0].start = true; // ensure matches are beside us →\n\n  var ptrs = this.fullPointer;\n  this.forEach(function (m, n) {\n    var more = m.after(regs, group);\n\n    if (more.found) {\n      var terms = more.terms();\n      ptrs[n][2] += terms.length;\n      ptrs[n][4] = null; //remove end-id\n    }\n  });\n  return this.update(ptrs);\n};\n\nvar grow = function grow(regs, group, opts) {\n  return this.growRight(regs, group, opts).growLeft(regs, group, opts);\n};\n\nexport default {\n  before: before,\n  after: after,\n  growLeft: growLeft,\n  growRight: growRight,\n  grow: grow\n};","map":null,"metadata":{},"sourceType":"module"}