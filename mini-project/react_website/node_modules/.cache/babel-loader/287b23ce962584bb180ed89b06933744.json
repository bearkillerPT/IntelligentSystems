{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { cleanAppend, cleanPrepend } from './lib/insert.js';\nimport uuid from '../compute/uuid.js'; // are we inserting inside a contraction?\n// expand it first\n\nvar expand = function expand(m) {\n  if (m.has('@hasContraction')) {\n    //&& m.after('^.').has('@hasContraction')\n    var more = m.grow('@hasContraction');\n    more.contractions().expand();\n  }\n};\n\nvar isArray = function isArray(arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n}; // set new ids for each terms\n\n\nvar addIds = function addIds(terms) {\n  terms = terms.map(function (term) {\n    term.id = uuid(term);\n    return term;\n  });\n  return terms;\n};\n\nvar getTerms = function getTerms(input, world) {\n  var methods = world.methods; // create our terms from a string\n\n  if (typeof input === 'string') {\n    return methods.one.tokenize.fromString(input, world)[0]; //assume one sentence\n  } //allow a view object\n\n\n  if (_typeof(input) === 'object' && input.isView) {\n    return input.clone().docs[0]; //assume one sentence\n  } //allow an array of terms, too\n\n\n  if (isArray(input)) {\n    return isArray(input[0]) ? input[0] : input;\n  }\n\n  return [];\n};\n\nvar insert = function insert(input, view, prepend) {\n  var document = view.document,\n      world = view.world; // insert words at end of each doc\n\n  var ptrs = view.fullPointer;\n  var selfPtrs = view.fullPointer;\n  view.forEach(function (m, i) {\n    var ptr = m.fullPointer[0];\n\n    var _ptr = _slicedToArray(ptr, 1),\n        n = _ptr[0]; // add-in the words\n\n\n    var home = document[n];\n    var terms = getTerms(input, world);\n    terms = addIds(terms);\n\n    if (prepend) {\n      expand(view.update([ptr]).firstTerm());\n      cleanPrepend(home, ptr, terms, document);\n    } else {\n      expand(view.update([ptr]).lastTerm());\n      cleanAppend(home, ptr, terms, document);\n    } // harden the pointer\n\n\n    if (document[n] && document[n][ptr[1]]) {\n      ptr[3] = document[n][ptr[1]].id;\n    } // change self backwards by len\n\n\n    selfPtrs[i] = ptr; // extend the pointer\n\n    ptr[2] += terms.length;\n    ptrs[i] = ptr;\n  });\n  var doc = view.toView(ptrs); // shift our self pointer, if necessary\n\n  view.ptrs = selfPtrs; // try to tag them, too\n\n  doc.compute(['id', 'index', 'lexicon']);\n\n  if (doc.world.compute.preTagger) {\n    doc.compute('preTagger');\n  }\n\n  return doc;\n};\n\nvar fns = {\n  insertAfter: function insertAfter(input) {\n    return insert(input, this, false);\n  },\n  insertBefore: function insertBefore(input) {\n    return insert(input, this, true);\n  }\n};\nfns.append = fns.insertAfter;\nfns.prepend = fns.insertBefore;\nfns.insert = fns.insertAfter;\nexport default fns;","map":null,"metadata":{},"sourceType":"module"}